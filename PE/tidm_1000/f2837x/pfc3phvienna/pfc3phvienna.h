/* ==============================================================================
System Name:

File Name:	  	voltagesourceinv_lcfltr.h

Target:

Author:

Description:

Copyright (C) {2015} Texas Instruments Incorporated - http://www.ti.com/
 * ALL RIGHTS RESERVED*
=================================================================================  */
#ifndef SOLUTION_H
#define SOLUTION_H

#ifdef __cplusplus

extern "C" {
#endif

//*****************************************************************************
// the includes
//*****************************************************************************

#include "pfc3phvienna_board.h"
// this is the file generated by the powerSUITE page for this system
#include "pfc3phvienna_settings.h"
#include "Solar_F.h"
#include "SFRA_F_Include.h"
#include "sineAnalyzerWithPowerMeas.h"

#define EMAVG_MACRO(in, out)			\
	out = ((in - out)*0.000528) + out;

//==================================================================================
// System Settings
//----------------------------------------------------------------------------------
//Add any system specific setting below
#if SFRA_TYPE==SFRA_VOLTAGE || SFRA_TYPE==SFRA_BALANCECNTL // voltage loop/ balance loop
#define SFRA_FREQ_START 2
#define SFRA_FREQ_LENGTH 30
//SFRA step Multiply = 10^(1/No of steps per decade(40))
#define FREQ_STEP_MULTIPLY (float)1.08
#define SFRA_AMPLITUDE (float)0.003
#elif SFRA_TYPE==SFRA_CURRENT  // current loop
#define SFRA_FREQ_START 200
#define SFRA_FREQ_LENGTH 100
//SFRA step Multiply = 10^(1/No of steps per decade(40))
#define FREQ_STEP_MULTIPLY (float)1.045
#define SFRA_AMPLITUDE (float)0.005
#endif

#define UNIVERSAL_GRID_MAX_VRMS 240
#define UNIVERSAL_GRID_MIN_VRMS 80
#define UNIVERSAL_GRID_MAX_FREQ 110
#define UNIVERSAL_GRID_MIN_FREQ 40

#define SD32_PU_SCALE_FACTOR  (float) ( 1.0 / ((float)SDFM_OSR*(float)SDFM_OSR*(float)SDFM_OSR))

#define newPWM 1

#define ALL_PHASE_ENABLED 1
#define CHECK_PHASE 2

#define DUTY_MAX 0.8

//*****************************************************************************
//globals
//*****************************************************************************
// Enum for power Stage Status
enum enum_boardState {
	PowerStageOFF = 0,
	PowerStageON=1,
	TripCondition = 2,
};

enum enum_BuildLevel {
	BuildLevel1_OpenLoop = 0,
	BuildLevel2_CurrentLoop = 2,
	BuildLevel3_VoltageAndCurrentLoop = 3,
	BuildLevel4_BalanceVoltageAndCurrentLoop = 4,
};

enum enum_boardStatus {
	boardStatus_Idle = 0,
	boardStatus_NoFault=1,
	boardStatus_OverCurrentTrip = 2,
	boardStatus_OverVoltageTrip = 3,
	boardStatus_EmulatorStopTrip = 4,
};

// Measurement Variables
// Inductor Current Measurement
extern volatile float iL1MeasADC,iL2MeasADC,iL3MeasADC;
extern volatile float iL1MeasSD,iL2MeasSD,iL3MeasSD;
extern volatile float iL1Meas,iL2Meas,iL3Meas;
// Inductor Current Measurement Offset
extern volatile float iL1MeasOffset,iL2MeasOffset,iL3MeasOffset;

// Output Voltage Bus measurement
extern volatile float vBusMNMeas,vBusPMMeas, vBusMeas, vBusHalfMeas;
extern volatile float vBusMNMeasAvg,vBusPMMeasAvg, vBusMeasAvg;

// variables used for calibration of output voltage measurements
extern volatile float m_VBusMNMeas, b_VBusMNMeas;
extern volatile float m_VBusPMMeas, b_VBusPMMeas;

// Input Grid Voltage Measurement
extern volatile float v1Meas,v2Meas,v3Meas;
extern volatile float v1MeasOffset,v2MeasOffset,v3MeasOffset;

// Flags for clearing trips and closing the loops
extern int16_t closeGiLoop,closeGvLoop, closeGsLoop, clearTrip, firstTimeGvLoop;

extern enum enum_BuildLevel BuildInfo;

extern enum enum_boardState boardState;

extern enum enum_boardStatus boardStatus;

//*****************************************************************************
// the function prototypes
//*****************************************************************************


// State Machine function prototypes
//------------------------------------
// Alpha states
void A0(void);	//state A0
void B0(void);	//state B0
void C0(void);	//state C0

// A branch states
void A1(void);	//state A1
void A2(void);	//state A2
void A3(void);	//state A3

// B branch states
void B1(void);	//state B1
void B2(void);	//state B2
void B3(void);	//state B3


#ifdef FLASH
#pragma CODE_SECTION(controlISR,"ramfuncs");
#endif
#pragma INTERRUPT (controlISR, HPI)
interrupt void controlISR(void);
#ifdef FLASH
#pragma CODE_SECTION(tenkHzISR,"ramfuncs");
#endif
interrupt void tenkHzISR(void);
inline void clearInterrupt(void);
inline void setupInterrupt(void);
void setupSFRA();
void updateBoardStatus(void);

//TODO readCurrVolADCSignals()
inline void readCurrVolADCSignals(void)
{
	/*offset165 = ((float32) (VREF165_FB))*ADC_PU_SCALE_FACTOR;*/

	iL1Meas = (((float32)(IL1_ADC_READ1+IL1_ADC_READ2+IL1_ADC_READ3+IL1_ADC_READ4))*ADC_PU_SCALE_FACTOR*0.25 - iL1MeasOffset )*2.0;
	iL2Meas = (((float32)(IL2_ADC_READ1+IL2_ADC_READ2+IL2_ADC_READ3+IL2_ADC_READ4))*ADC_PU_SCALE_FACTOR*0.25 - iL2MeasOffset )*2.0;
	iL3Meas = (((float32)(IL3_ADC_READ1+IL3_ADC_READ2+IL3_ADC_READ3+IL3_ADC_READ4))*ADC_PU_SCALE_FACTOR*0.25 - iL3MeasOffset )*2.0;

	v1Meas = (((float32)(V1_ADC_READ1+V1_ADC_READ2+V1_ADC_READ3+V1_ADC_READ4))*ADC_PU_SCALE_FACTOR*0.25 - v1MeasOffset )*2.0;
	v2Meas = (((float32)(V2_ADC_READ1+V2_ADC_READ2+V2_ADC_READ3+V2_ADC_READ4))*ADC_PU_SCALE_FACTOR*0.25 - v2MeasOffset )*2.0;
	v3Meas = (((float32)(V3_ADC_READ1+V3_ADC_READ2+V3_ADC_READ3+V3_ADC_READ4))*ADC_PU_SCALE_FACTOR*0.25 - v3MeasOffset )*2.0;

	vBusPMMeas = (((float32)(VBUSPM_ADC_READ1+VBUSPM_ADC_READ2+VBUSPM_ADC_READ3+VBUSPM_ADC_READ4))*ADC_PU_SCALE_FACTOR*0.25 )*VDCBUS_MAX_SENSE/VAC_MAX_SENSE;
	vBusMNMeas = (((float32)(VBUSMN_ADC_READ1+VBUSMN_ADC_READ2+VBUSMN_ADC_READ3+VBUSMN_ADC_READ4))*ADC_PU_SCALE_FACTOR*0.25 )*VDCBUS_MAX_SENSE/VAC_MAX_SENSE;

	vBusPMMeas = m_VBusPMMeas*vBusPMMeas + b_VBusPMMeas; // y= mx+ b equation used to reduce offset and gain error
	vBusMNMeas = m_VBusMNMeas*vBusMNMeas + b_VBusMNMeas;

	vBusMeas= vBusPMMeas+vBusMNMeas;
	vBusHalfMeas = (vBusMeas)*0.5;
	// clamp the vBusHalfMeas before dividing to avoid NaN
	vBusHalfMeas = (vBusHalfMeas<0.2)?0.2:vBusHalfMeas;
}

//TODO readCurrVolSDFMSignals()
inline void readCurrVolSDFMSignals(float sdfm_scale_factor)
{
	// temp variable used to read in the SD value
	int32_t sd1Flt1Read;
	int32_t sd1Flt2Read;
	int32_t sd1Flt3Read;

	sd1Flt1Read=SDFM_READ_FILTER1_DATA_32BIT;
	sd1Flt2Read=SDFM_READ_FILTER2_DATA_32BIT;
	sd1Flt3Read=SDFM_READ_FILTER3_DATA_32BIT;

	iL1MeasSD=sd1Flt1Read*sdfm_scale_factor;
	iL2MeasSD=sd1Flt2Read*sdfm_scale_factor;
	iL3MeasSD=sd1Flt3Read*sdfm_scale_factor;

}

//TODO clearPWMTrip()
inline void clearPWMTrip()
{

	if (clearTrip==1 )
	{
		// clear all the configured trip sources for the PWM module

		clearPWMTripFlags(PWM_NO);
		clearPWMTripFlags(PWM_NO+1);
		clearPWMTripFlags(PWM_NO+2);

		clearTrip=0;
		closeGiLoop=1;

#if INCR_BUILD==3 || INCR_BUILD==4
		closeGvLoop=1;
		closeGsLoop=1;
#else
		closeGvLoop=0;
#endif

		boardStatus= boardStatus_NoFault;
	}

}

//TODO computePIcontrollerCoeff()
// PI = (gain)*(s+z0)/s
void computePIcontrollerCoeff(CNTL_2P2Z_F_COEFFS *coef1, float gain, float z0, float fsw)
{
	float temp1;
	temp1=gain/(2*fsw);

	coef1->Coeff_B0=(2*fsw+z0)*temp1;
	coef1->Coeff_B1=(-2*fsw+z0)*temp1;
	coef1->Coeff_B2=0;
	coef1->Coeff_A1=1;
	coef1->Coeff_A2=0;
	coef1->IMin=-1.0;
	coef1->Max=1.0;
	coef1->Min=-1.0;
}

#ifdef __cplusplus
}
#endif                                  /* extern "C" */


#endif
